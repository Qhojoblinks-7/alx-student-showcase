// social-content-optimizer.js

// This class is responsible for generating platform-specific social media content.
export class SocialContentOptimizer {
  // Platform specifications
  static PLATFORM_LIMITS = {
    twitter: {
      maxLength: 280,
      urlLength: 23, // Twitter auto-shortens URLs to 23 chars
      hashtagWeight: 1,
      priority: ['impact', 'tech', 'url'], // What to prioritize in short content
    },
    linkedin: {
      maxLength: 3000,
      optimalLength: 1300, // Sweet spot for engagement
      priority: ['story', 'impact', 'tech', 'url'],
    },
    facebook: {
      maxLength: 63206,
      optimalLength: 400, // Optimal for engagement
      priority: ['story', 'impact', 'visual', 'url'],
    },
    discord: {
      maxLength: 2000,
      priority: ['impact', 'tech', 'code', 'url'],
    }
  };

  /**
   * Generates optimized content for each social media platform.
   * It now expects the AI-generated work log summary as a string.
   *
   * @param {object} project - The project object (from Redux state).
   * @param {string|null} aiWorkLogSummaryText - The humanized work log summary generated by AI.
   * @param {Array<Object>} [rawCommits=[]] - Optional: Raw commit objects if internal analysis is needed for smart content.
   * @param {string} [customMessage=''] - Optional: A custom message provided by the user.
   * @returns {object} An object containing optimized content for each platform.
   */
  static generatePlatformContent(project, aiWorkLogSummaryText = null, rawCommits = [], customMessage = '') {
    // Perform internal commit analysis if raw commits are provided and needed for smart content
    const internalWorkLogSummary = rawCommits.length > 0 ? this.analyzeCommits(rawCommits) : null;

    const baseData = {
      project,
      aiWorkLogSummaryText, // Now a string
      internalWorkLogSummary, // Structured analysis from raw commits
      customMessage,
      timestamp: new Date()
    };

    const twitterContent = this.generateTwitterContent(baseData);
    const linkedinContent = this.generateLinkedInContent(baseData);
    const facebookContent = this.generateFacebookContent(baseData);
    const discordContent = this.generateDiscordContent(baseData);

    // Add a fallback if content is unexpectedly empty
    const defaultMessage = `Check out my project: ${project.title || 'A new project'}!`;

    return {
      twitter: {
        ...twitterContent,
        content: twitterContent.content || defaultMessage + (project.github_url ? ` ${project.github_url}` : '')
      },
      linkedin: {
        ...linkedinContent,
        content: linkedinContent.content || defaultMessage + (project.live_url || project.github_url ? ` Learn more: ${project.live_url || project.github_url}` : '')
      },
      facebook: {
        ...facebookContent,
        content: facebookContent.content || defaultMessage + (project.live_url || project.github_url ? ` Find it here: ${project.live_url || project.github_url}` : '')
      },
      discord: {
        ...discordContent,
        content: discordContent.content || defaultMessage + (project.live_url || project.github_url ? ` Link: ${project.live_url || project.github_url}` : '')
      }
    };
  }

  // --- Internal Commit Analysis (moved from GitHubCommitsService) ---
  /**
   * Analyzes raw commit messages to extract work patterns and categories.
   * This is a rule-based analysis, not AI.
   * @param {Array<Object>} commits - An array of raw commit objects.
   * @returns {object} Structured summary of commit activities.
   */
  static analyzeCommits(commits) {
    const features = [];
    const fixes = [];
    const improvements = [];
    const categories = {
      features: 0,
      fixes: 0,
      docs: 0,
      tests: 0,
      refactor: 0,
      style: 0,
      chore: 0
    };

    let firstCommitDate = null;
    let lastCommitDate = null;

    commits.forEach(commit => {
      const message = commit.message.toLowerCase();
      const commitDate = new Date(commit.date); // Assuming commit.date is available and parsable

      if (!firstCommitDate || commitDate < firstCommitDate) {
        firstCommitDate = commitDate;
      }
      if (!lastCommitDate || commitDate > lastCommitDate) {
        lastCommitDate = commitDate;
      }

      // Categorize commits based on common prefixes/keywords
      if (message.startsWith('feat') || message.includes('add') || message.includes('implement')) {
        features.push(commit.message);
        categories.features++;
      } else if (message.startsWith('fix') || message.includes('bug') || message.includes('resolve')) {
        fixes.push(commit.message);
        categories.fixes++;
      } else if (message.includes('improve') || message.includes('update') || message.includes('enhance')) {
        improvements.push(commit.message);
      } else if (message.startsWith('docs') || message.includes('doc') || message.includes('readme')) {
        categories.docs++;
      } else if (message.startsWith('test')) {
        categories.tests++;
      } else if (message.startsWith('refactor') || message.includes('clean')) {
        categories.refactor++;
      } else if (message.startsWith('style') || message.includes('format')) {
        categories.style++;
      } else if (message.startsWith('chore') || message.includes('config') || message.includes('build')) {
        categories.chore++;
      }
    });

    const totalCommits = commits.length;
    const mostActiveArea = Object.keys(categories).reduce((a, b) =>
      categories[a] > categories[b] ? a : b
      , 'none');

    return {
      features: features.slice(0, 3), // Top 3 feature messages
      fixes: fixes.slice(0, 2),     // Top 2 fix messages
      improvements: improvements.slice(0, 2), // Top 2 improvement messages
      categories, // Counts per category
      mostActiveArea, // The category with the highest count
      totalCommits, // Total commits analyzed
      firstCommitDate, // Added for dynamic timeframe calculation
      lastCommitDate,  // Added for dynamic timeframe calculation
    };
  }

  // Twitter/X optimized content (280 chars max)
  static generateTwitterContent({ project, aiWorkLogSummaryText, internalWorkLogSummary, customMessage }) {
    const limit = this.PLATFORM_LIMITS.twitter;

    // Build content components with smart personalization
    const components = {
      hook: customMessage || this.generatePersonalizedHook(project, internalWorkLogSummary, 'twitter'),
      // Use AI summary directly for the main progress/story part
      aiSummary: aiWorkLogSummaryText || '',
      tech: this.generateTechStack(project.technologies, 'twitter'),
      hashtags: this.generateSmartHashtags(project, internalWorkLogSummary, 'twitter'),
      url: project.live_url || project.github_url || ''
    };

    // Calculate available space with smart URL handling
    const urlSpace = components.url ? limit.urlLength + 1 : 0; // +1 for space
    const hashtagSpace = components.hashtags.length > 0 ? components.hashtags.length + 1 : 0; // +1 for space if hashtags exist
    const availableSpace = limit.maxLength - urlSpace - hashtagSpace;

    // Smart content building with multiple strategies
    let content = this.buildOptimalTwitterContent(components, availableSpace);

    // Add hashtags and URL
    const finalContent = [
      content.trim(),
      components.hashtags,
      components.url
    ].filter(Boolean).join('\n\n'); // Use double newline for better readability on Twitter

    // If still too long, apply aggressive compression
    if (finalContent.length > limit.maxLength) {
      return this.applyAggressiveTwitterCompression(components, limit);
    }

    return {
      content: finalContent,
      length: finalContent.length,
      components,
      optimized: true
    };
  }

  // Smart content building for Twitter with multiple strategies
  static buildOptimalTwitterContent(components, availableSpace) {
    let content = components.hook || '';

    // Prioritize AI summary if available and fits
    if (components.aiSummary) {
      const aiSummaryTruncated = this.truncateWithEllipsis(components.aiSummary, availableSpace - content.length - 10); // Reserve space
      if ((content + '\n\n' + aiSummaryTruncated).length <= availableSpace) {
        content += '\n\n' + aiSummaryTruncated;
      } else {
        // If AI summary doesn't fit with hook, try just AI summary
        content = this.truncateWithEllipsis(components.aiSummary, availableSpace);
      }
    }

    // Add condensed tech if space allows
    const remainingSpace = availableSpace - content.length;
    if (components.tech && remainingSpace > 15) {
      const condensedTech = this.condenseTechStack(components.tech, remainingSpace - 2);
      if (condensedTech) {
        content += '\n\n' + condensedTech;
      }
    }

    return content;
  }

  // Aggressive compression for Twitter when standard methods exceed limit
  static applyAggressiveTwitterCompression(components, limit) {
    const maxContentSpace = limit.maxLength - (components.url ? limit.urlLength + 1 : 0) - 50; // Reserve space for minimal hashtags and URL

    // Ultra-compact format
    const parts = [];

    // Minimal hook
    const hook = this.getMinimalHook(components.hook);
    parts.push(hook);

    // Essential info only from AI summary
    if (components.aiSummary) {
      const minAISummary = this.truncateWithEllipsis(components.aiSummary, maxContentSpace / 2); // Take half the remaining space
      if (minAISummary) parts.push(minAISummary);
    }

    // Minimal tech (just top 2)
    if (components.tech) {
      const minTech = this.getMinimalTech(components.tech);
      if (minTech) parts.push(minTech);
    }

    let content = parts.filter(Boolean).join(' • '); // Join with bullet for compactness

    // Final truncation if still too long
    if (content.length > maxContentSpace) {
      content = this.truncateWithEllipsis(content, maxContentSpace);
    }

    // Minimal hashtags
    const minHashtags = this.getMinimalHashtags(components.hashtags);

    const finalContent = [content, minHashtags, components.url].filter(Boolean).join('\n');

    return {
      content: finalContent,
      length: finalContent.length,
      components,
      optimized: true,
      compressed: true
    };
  }

  // Smart text abbreviation
  static abbreviateText(text, maxLength) {
    if (text.length <= maxLength) return text;

    // Try to find natural break points
    const sentences = text.split(/[.!?]/);
    if (sentences[0] && sentences[0].length <= maxLength) {
      return sentences[0] + (sentences.length > 1 ? '...' : '');
    }

    // Remove less important words
    const words = text.split(' ');
    const importantWords = words.filter(word =>
      !['the', 'a', 'an', 'is', 'was', 'were', 'and', 'or', 'but', 'in', 'on', 'at', 'to'].includes(word.toLowerCase())
    );

    let abbreviated = importantWords.join(' ');
    if (abbreviated.length <= maxLength) return abbreviated;

    // Final truncation
    return this.truncateWithEllipsis(text, maxLength);
  }

  // Condensed tech stack for space-constrained platforms
  static condenseTechStack(tech, maxLength) {
    if (tech.length <= maxLength) return tech;

    // Extract just technology names, remove "Built with", "Tech:", etc.
    const cleanTech = tech.replace(/^(Tech:|Built with:|🛠️\s*)/i, '');
    if (cleanTech.length <= maxLength) return cleanTech;

    // Abbreviate common technologies
    const abbreviated = cleanTech
      .replace(/JavaScript/gi, 'JS')
      .replace(/TypeScript/gi, 'TS')
      .replace(/Python/gi, 'Python')
      .replace(/, /g, ','); // Remove spaces after commas

    if (abbreviated.length <= maxLength) return abbreviated;

    // Take only first 2-3 technologies
    const techs = abbreviated.split(',');
    return techs.slice(0, 2).join(',') + (techs.length > 2 ? '+' : '');
  }

  // Get minimal versions for aggressive compression
  static getMinimalHook(hook) {
    return hook
      .replace(/🚀 Just shipped /, '🚀 ')
      .replace(/✨ (.+) is now live!/, '✨ $1 live!')
      .replace(/🎉 Completed /, '🎉 ')
      .replace(/💻 New project alert: /, '💻 ');
  }

  static getMinimalTech(tech) {
    const cleanTech = tech.replace(/^(Tech:|Built with:|�️\s*)/i, '');
    const techs = cleanTech.split(/[,\s]+/).filter(Boolean);
    return techs.slice(0, 2).join(',');
  }

  static getMinimalHashtags(hashtags) {
    const tags = hashtags.split(' ').filter(tag => tag.startsWith('#'));
    return tags.slice(0, 2).join(' '); // Only top 2 hashtags for ultra-compact
  }

  // LinkedIn optimized content
  static generateLinkedInContent({ project, aiWorkLogSummaryText, internalWorkLogSummary, customMessage }) {
    const hook = customMessage || this.generateHook(project, 'linkedin');
    const story = this.generateStory(project, internalWorkLogSummary); // Story can still use internal analysis
    const achievement = this.generateAchievement(project, internalWorkLogSummary, 'linkedin');
    const tech = this.generateTechStack(project.technologies, 'linkedin');
    // Use AI summary for the main work log progress
    const progress = aiWorkLogSummaryText ? `Recent progress:\n${aiWorkLogSummaryText}` : '';
    const reflection = this.generateReflection(project, internalWorkLogSummary);
    const hashtags = this.generateHashtags(project, 'linkedin');
    const url = project.live_url || project.github_url || '';

    const content = [
      hook,
      '',
      story,
      '',
      achievement,
      '',
      progress, // Directly use AI summary here
      '',
      tech,
      '',
      reflection,
      '',
      hashtags,
      '',
      url ? `🔗 ${url}` : ''
    ].filter(Boolean).join('\n');

    return {
      content,
      length: content.length,
      optimized: content.length <= this.PLATFORM_LIMITS.linkedin.optimalLength
    };
  }

  // Facebook optimized content
  static generateFacebookContent({ project, aiWorkLogSummaryText, internalWorkLogSummary, customMessage }) {
    const hook = customMessage || this.generateHook(project, 'facebook');
    const story = this.generateStory(project, internalWorkLogSummary);
    const achievement = this.generateAchievement(project, internalWorkLogSummary, 'facebook');
    // Use AI summary for the main work log progress
    const progress = aiWorkLogSummaryText ? `Recent updates:\n${aiWorkLogSummaryText}` : '';
    const url = project.live_url || project.github_url || '';

    const content = [
      hook,
      '',
      story,
      '',
      achievement,
      '',
      progress, // Directly use AI summary here
      '',
      url ? `Check it out: ${url}` : ''
    ].filter(Boolean).join('\n');

    return {
      content,
      length: content.length,
      optimized: content.length <= this.PLATFORM_LIMITS.facebook.optimalLength
    };
  }

  // Discord optimized content
  static generateDiscordContent({ project, aiWorkLogSummaryText, internalWorkLogSummary, customMessage }) {
    const hook = customMessage || `🎉 **${project.title}** is live!`;
    const description = project.description;
    const tech = `**Tech Stack:** ${project.technologies?.join(', ') || 'Various technologies'}`;
    // Use AI summary for the main work log progress
    const progress = aiWorkLogSummaryText ? `**Recent Progress:**\n${aiWorkLogSummaryText}` : '';
    const url = project.live_url || project.github_url || '';

    const content = [
      hook,
      '',
      description,
      '',
      tech,
      '',
      progress, // Directly use AI summary here
      '',
      url ? `🔗 ${url}` : ''
    ].filter(Boolean).join('\n');

    return {
      content,
      length: content.length,
      optimized: content.length <= this.PLATFORM_LIMITS.discord.maxLength
    };
  }

  // Content generators
  static generateHook(project, platform) {
    const hooks = {
      twitter: [
        `🚀 Just shipped ${project.title}!`,
        `✨ ${project.title} is now live!`,
        `🎉 Completed ${project.title}!`,
        `💻 New project alert: ${project.title}`
      ],
      linkedin: [
        `🚀 Excited to share my latest project: ${project.title}`,
        `✨ Just completed an amazing project during my ALX journey: ${project.title}`,
        `💻 Proud to present ${project.title} - another milestone in my software engineering journey`,
        `🎯 Project spotlight: ${project.title}`
      ],
      facebook: [
        `🚀 Just finished working on ${project.title} and I'm really excited to share it!`,
        `✨ Hey everyone! I just completed ${project.title} as part of my ALX Software Engineering program`,
        `💻 Sharing my latest coding project: ${project.title}`
      ]
    };

    const platformHooks = hooks[platform] || hooks.twitter;
    return platformHooks[Math.floor(Math.random() * platformHooks.length)];
  }

  // Personalized hook generation based on commit activity
  static generatePersonalizedHook(project, internalWorkLogSummary, platform) {
    if (!internalWorkLogSummary || !internalWorkLogSummary.mostActiveArea) {
      return this.generateHook(project, platform);
    }

    const { mostActiveArea, categories, totalCommits } = internalWorkLogSummary;

    // Personalize based on commit activity
    const personalizedHooks = {
      twitter: {
        features: [
          `🚀 ${project.title} packed with new features!`,
          `✨ Feature-rich ${project.title} is live!`,
          `🎉 ${project.title} with ${categories.features} new features!`
        ],
        fixes: [
          `🐛 ${project.title} now bug-free & polished!`,
          `✅ ${project.title} refined & ready!`,
          `🚀 ${project.title} optimized & shipped!`
        ],
        refactor: [
          `⚡ ${project.title} rebuilt & improved!`,
          `🔥 ${project.title} completely refactored!`,
          `✨ ${project.title} clean & optimized!`
        ],
        docs: [
          `📚 ${project.title} fully documented & live!`,
          `✨ ${project.title} with complete docs!`,
          `🚀 ${project.title} documented & ready!`
        ]
      }
    };

    const platformHooks = personalizedHooks[platform]?.[mostActiveArea];
    if (platformHooks) {
      return platformHooks[Math.floor(Math.random() * platformHooks.length)];
    }

    // Fallback with activity context
    if (totalCommits > 10) {
      return `🔥 After ${totalCommits} commits, ${project.title} is ready!`;
    } else if (totalCommits > 5) {
      return `💪 ${totalCommits} commits later, ${project.title} is live!`;
    }

    return this.generateHook(project, platform);
  }

  // Smart progress generation with context awareness (now based on internal analysis)
  static generateSmartProgress(internalWorkLogSummary, platform) {
    if (!internalWorkLogSummary) return '';

    const { categories, mostActiveArea, totalCommits } = internalWorkLogSummary;

    if (platform === 'twitter') {
      // Ultra-compact for Twitter
      if (totalCommits > 20) return `${totalCommits}c 🔥`;
      if (totalCommits > 10) return `${totalCommits}c 💪`;
      if (totalCommits > 5) return `${totalCommits}c`;
      return `${totalCommits}c`;
    }

    // More detailed for other platforms
    const highlights = [];
    if (categories.features > 0) highlights.push(`${categories.features} features`);
    if (categories.fixes > 0) highlights.push(`${categories.fixes} fixes`);
    if (categories.refactor > 0) highlights.push(`${categories.refactor} refactors`);

    if (highlights.length === 0) {
      return `📈 ${totalCommits} commits`;
    }

    return `📈 ${totalCommits} commits: ${highlights.join(', ')}`;
  }

  // Smart hashtag generation based on project and activity
  static generateSmartHashtags(project, internalWorkLogSummary, platform) {
    const baseTags = ['#ALXStudents', '#SoftwareEngineering'];

    // Add technology-specific tags using the robust normalizeTechTag
    const techTags = project.technologies?.slice(0, 2).map(tech =>
      `#${this.normalizeTechTag(tech)}`
    ) || [];

    // Add activity-based tags (from internal analysis)
    const activityTags = [];
    if (internalWorkLogSummary) {
      const { mostActiveArea, categories } = internalWorkLogSummary;

      if (categories.features > 3) activityTags.push('#NewFeatures');
      if (categories.fixes > 2) activityTags.push('#BugFixes');
      if (categories.refactor > 2) activityTags.push('#CodeRefactor');
      if (mostActiveArea === 'features') activityTags.push('#FeatureDev');
    }

    // Category-specific tags
    const categoryTags = {
      'web': ['#WebDev'],
      'backend': ['#Backend'],
      'mobile': ['#MobileApp'],
      'ai': ['#MachineLearning'],
      'data': ['#DataScience'],
      'devops': ['#DevOps']
    };

    const projectTags = categoryTags[project.category]?.slice(0, 1) || [];

    let allTags = [...baseTags, ...techTags, ...activityTags, ...projectTags];

    // Platform-specific limits and optimization
    if (platform === 'twitter') {
      allTags = allTags.slice(0, 3); // Strict limit for Twitter
    } else if (platform === 'linkedin') {
      allTags = allTags.slice(0, 5);
      allTags.push('#Coding'); // LinkedIn loves this
    }

    return allTags.join(' ');
  }

  // Normalize technology names for hashtags
  static normalizeTechTag(tech) {
    const normalized = tech
      .replace(/[^a-zA-Z0-9]/g, '') // Remove special characters
      .replace(/JavaScript/gi, 'JavaScript')
      .replace(/TypeScript/gi, 'TypeScript')
      .replace(/React/gi, 'ReactJS')
      .replace(/Vue/gi, 'VueJS')
      .replace(/Node/gi, 'NodeJS');

    return normalized.charAt(0).toUpperCase() + normalized.slice(1);
  }

  static generateAchievement(project, internalWorkLogSummary, platform) {
    if (!internalWorkLogSummary || !internalWorkLogSummary.firstCommitDate || !internalWorkLogSummary.lastCommitDate) return '';

    const { totalCommits, firstCommitDate, lastCommitDate } = internalWorkLogSummary;

    // Calculate timeframe dynamically
    const diffTime = Math.abs(lastCommitDate.getTime() - firstCommitDate.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    let timeframeDescription = '';
    if (diffDays <= 1) {
      timeframeDescription = 'past 24 hours';
    } else if (diffDays <= 7) {
      timeframeDescription = 'past week';
    } else if (diffDays <= 30) {
      timeframeDescription = 'past month';
    } else {
      timeframeDescription = `${diffDays} days`;
    }

    if (platform === 'twitter') {
      return `${totalCommits} commits in ${timeframeDescription}`;
    }

    return `📈 Development highlights: ${totalCommits} commits over the ${timeframeDescription}`;
  }

  static generateStory(project, internalWorkLogSummary) {
    const stories = [
      `This project challenged me to dive deep into ${project.technologies?.[0] || 'new technologies'} and I'm thrilled with the results.`,
      `Working on this project has been an incredible learning experience, especially exploring ${project.technologies?.slice(0, 2).join(' and ') || 'new technologies'}.`,
      `${project.title} represents hours of problem-solving, debugging, and creative thinking.`
    ];

    // Add a story element based on commit activity if available
    if (internalWorkLogSummary && internalWorkLogSummary.mostActiveArea !== 'none') {
      const { mostActiveArea, totalCommits } = internalWorkLogSummary;
      const activitySentence = `Focused heavily on ${mostActiveArea} with ${totalCommits} commits.`;
      return stories[Math.floor(Math.random() * stories.length)] + ' ' + activitySentence;
    }

    return stories[Math.floor(Math.random() * stories.length)];
  }

  static generateReflection(project, internalWorkLogSummary) {
    const reflections = [
      `This project reinforced my passion for software engineering and problem-solving. Can't wait to tackle the next challenge! 💪`,
      `Every project teaches me something new. Grateful for the ALX program and the amazing learning journey. 🙏`,
      `Building projects like this reminds me why I love coding. The satisfaction of seeing your ideas come to life is unmatched! ✨`,
      `The journey through this project was a testament to perseverance and continuous learning. Excited for what's next!`,
      `Proud to add this project to my portfolio, showcasing growth and dedication in my ALX journey.`
    ];

    return reflections[Math.floor(Math.random() * reflections.length)];
  }

  static generateTechStack(technologies, platform) {
    if (!technologies || technologies.length === 0) return '';

    if (platform === 'twitter') {
      // Limit to 3 most important technologies for Twitter
      const topTech = technologies.slice(0, 3);
      return `Tech: ${topTech.join(', ')}`;
    }

    return `🛠️ Built with: ${technologies.join(', ')}`;
  }

  static generateHashtags(project, platform) {
    const baseTags = ['#ALXStudents', '#SoftwareEngineering', '#Coding'];
    // Use normalizeTechTag for consistency
    const techTags = project.technologies?.slice(0, 2).map(tech =>
      `#${this.normalizeTechTag(tech)}`
    ) || [];

    const categoryTags = {
      'web': ['#WebDev', '#Frontend'],
      'backend': ['#Backend', '#API'],
      'mobile': ['#MobileApp', '#AppDev'],
      'ai': ['#MachineLearning', '#AI'],
      'data': ['#DataScience', '#Analytics'],
      'devops': ['#DevOps', '#Infrastructure']
    };

    const projectTags = categoryTags[project.category] || [];

    let allTags = [...baseTags, ...techTags, ...projectTags];

    // Platform-specific tag limits
    if (platform === 'twitter') {
      allTags = allTags.slice(0, 4); // Limit hashtags for Twitter
    } else if (platform === 'linkedin') {
      allTags = allTags.slice(0, 6);
    }

    return allTags.join(' ');
  }

  // Utility methods
  static truncateWithEllipsis(text, maxLength) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }
}
